diff -pruN ffmpeg-4.0.2/fftools/ffmpeg_opt.c upd_ffmpeg-4.0.2/fftools/ffmpeg_opt.c
--- ffmpeg-4.0.2/fftools/ffmpeg_opt.c	2018-07-18 20:51:59.000000000 +0700
+++ upd_ffmpeg-4.0.2/fftools/ffmpeg_opt.c	2018-10-05 14:33:17.858048722 +0700
@@ -117,6 +117,7 @@ static int file_overwrite     = 0;
 static int no_file_overwrite  = 0;
 static int do_psnr            = 0;
 static int input_sync;
+static int override_ffserver  = 0;
 static int input_stream_potentially_available = 0;
 static int ignore_unknown_streams = 0;
 static int copy_unknown_streams = 0;
@@ -1996,6 +1997,56 @@ static int copy_chapters(InputFile *ifil
     return 0;
 }
 
+static int read_ffserver_streams(OptionsContext *o, AVFormatContext *s, const char *filename)
+{
+    int i, err;
+    AVFormatContext *ic = avformat_alloc_context();
+
+    ic->interrupt_callback = int_cb;
+    err = avformat_open_input(&ic, filename, NULL, NULL);
+    if (err < 0)
+        return err;
+    /* copy stream format */
+    for(i=0;i<ic->nb_streams;i++) {
+        AVStream *st;
+        OutputStream *ost;
+        AVCodec *codec;
+        const char *enc_config;
+
+        codec = avcodec_find_encoder(ic->streams[i]->codecpar->codec_id);
+        if (!codec) {
+            av_log(s, AV_LOG_ERROR, "no encoder found for codec id %i\n", ic->streams[i]->codecpar->codec_id);
+            return AVERROR(EINVAL);
+        }
+        if (codec->type == AVMEDIA_TYPE_AUDIO)
+            opt_audio_codec(o, "c:a", codec->name);
+        else if (codec->type == AVMEDIA_TYPE_VIDEO)
+            opt_video_codec(o, "c:v", codec->name);
+        ost   = new_output_stream(o, s, codec->type, -1);
+        st    = ost->st;
+
+        avcodec_get_context_defaults3(st->codec, codec);
+        enc_config = av_stream_get_recommended_encoder_configuration(ic->streams[i]);
+        if (enc_config) {
+            AVDictionary *opts = NULL;
+            av_dict_parse_string(&opts, enc_config, "=", ",", 0);
+            av_opt_set_dict2(st->codec, &opts, AV_OPT_SEARCH_CHILDREN);
+            av_dict_free(&opts);
+        }
+
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && !ost->stream_copy)
+            choose_sample_fmt(st, codec);
+        else if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && !ost->stream_copy)
+            choose_pixel_fmt(st, st->codec, codec, st->codecpar->format);
+        avcodec_copy_context(ost->enc_ctx, st->codec);
+        if (enc_config)
+            av_dict_parse_string(&ost->encoder_opts, enc_config, "=", ",", 0);
+    }
+
+    avformat_close_input(&ic);
+    return err;
+}
+
 static void init_output_filter(OutputFilter *ofilter, OptionsContext *o,
                                AVFormatContext *oc)
 {
@@ -2054,6 +2105,7 @@ static int open_output_file(OptionsConte
 {
     AVFormatContext *oc;
     int i, j, err;
+    AVOutputFormat *file_oformat;
     OutputFile *of;
     OutputStream *ost;
     InputStream  *ist;
@@ -2102,6 +2154,7 @@ static int open_output_file(OptionsConte
     if (o->recording_time != INT64_MAX)
         oc->duration = o->recording_time;
 
+    file_oformat= oc->oformat;
     oc->interrupt_callback = int_cb;
 
     e = av_dict_get(o->g->format_opts, "fflags", NULL, 0);
@@ -2132,7 +2185,46 @@ static int open_output_file(OptionsConte
         }
     }
 
-    if (!o->nb_stream_maps) {
+    /* ffserver seeking with date=... needs a date reference */
+    if (!strcmp(file_oformat->name, "ffm") &&
+        av_strstart(filename, "http:", NULL)) {
+        int err = parse_option(o, "metadata", "creation_time=now", options);
+        if (err < 0) {
+            print_error(filename, err);
+            exit_program(1);
+        }
+    }
+
+    if (!strcmp(file_oformat->name, "ffm") && !override_ffserver &&
+        av_strstart(filename, "http:", NULL)) {
+        int j;
+        /* special case for files sent to ffserver: we get the stream
+           parameters from ffserver */
+        int err = read_ffserver_streams(o, oc, filename);
+        if (err < 0) {
+            print_error(filename, err);
+            exit_program(1);
+        }
+        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {
+            ost = output_streams[j];
+            for (i = 0; i < nb_input_streams; i++) {
+                ist = input_streams[i];
+                if(ist->st->codecpar->codec_type == ost->st->codecpar->codec_type){
+                    ost->sync_ist= ist;
+                    ost->source_index= i;
+                    if(ost->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup("anull");
+                    if(ost->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup("null");
+                    ist->discard = 0;
+                    ist->st->discard = ist->user_set_discard;
+                    break;
+                }
+            }
+            if(!ost->sync_ist){
+                av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(ost->st->codecpar->codec_type));
+                exit_program(1);
+            }
+        }
+    } else if (!o->nb_stream_maps) {
         char *subtitle_codec_name = NULL;
         /* pick the "best" stream of each type */
 
@@ -3625,6 +3717,8 @@ const OptionDef options[] = {
         "set the maximum demux-decode delay", "seconds" },
     { "muxpreload", OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT, { .off = OFFSET(mux_preload) },
         "set the initial demux-decode delay", "seconds" },
+    { "override_ffserver", OPT_BOOL | OPT_EXPERT | OPT_OUTPUT, { &override_ffserver },
+        "override the options from ffserver", "" },
     { "sdp_file", HAS_ARG | OPT_EXPERT | OPT_OUTPUT, { .func_arg = opt_sdp_file },
         "specify a file in which to print sdp information", "file" },
 
diff -pruN ffmpeg-4.0.2/libavformat/allformats.c upd_ffmpeg-4.0.2/libavformat/allformats.c
--- ffmpeg-4.0.2/libavformat/allformats.c	2018-07-18 20:52:01.000000000 +0700
+++ upd_ffmpeg-4.0.2/libavformat/allformats.c	2018-10-05 10:22:57.368213050 +0700
@@ -129,6 +129,8 @@ extern AVInputFormat  ff_eac3_demuxer;
 extern AVOutputFormat ff_eac3_muxer;
 extern AVInputFormat  ff_epaf_demuxer;
 extern AVOutputFormat ff_f4v_muxer;
+extern AVInputFormat  ff_ffm_demuxer;
+extern AVOutputFormat ff_ffm_muxer;
 extern AVInputFormat  ff_ffmetadata_demuxer;
 extern AVOutputFormat ff_ffmetadata_muxer;
 extern AVOutputFormat ff_fifo_muxer;
diff -pruN ffmpeg-4.0.2/libavformat/ffmdec.c upd_ffmpeg-4.0.2/libavformat/ffmdec.c
--- ffmpeg-4.0.2/libavformat/ffmdec.c	1970-01-01 08:00:00.000000000 +0800
+++ upd_ffmpeg-4.0.2/libavformat/ffmdec.c	2018-10-05 10:15:10.812561412 +0700
@@ -0,0 +1,878 @@
+/*
+ * FFM (ffserver live feed) demuxer
+ * Copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "libavutil/imgutils.h"
+#include "libavutil/internal.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/intfloat.h"
+#include "libavutil/opt.h"
+#include "libavutil/avassert.h"
+#include "libavutil/avstring.h"
+#include "libavutil/pixdesc.h"
+#include "libavcodec/internal.h"
+#include "avformat.h"
+#include "internal.h"
+#include "ffm.h"
+#include "avio_internal.h"
+
+static int ffm_is_avail_data(AVFormatContext *s, int size)
+{
+    FFMContext *ffm = s->priv_data;
+    int64_t pos, avail_size;
+    ptrdiff_t len;
+
+    len = ffm->packet_end - ffm->packet_ptr;
+    if (size <= len)
+        return 1;
+    pos = avio_tell(s->pb);
+    if (!ffm->write_index) {
+        if (pos == ffm->file_size)
+            return AVERROR_EOF;
+        avail_size = ffm->file_size - pos;
+    } else {
+    if (pos == ffm->write_index) {
+        /* exactly at the end of stream */
+        if (ffm->server_attached)
+            return AVERROR(EAGAIN);
+        else
+            return AVERROR_INVALIDDATA;
+    } else if (pos < ffm->write_index) {
+        avail_size = ffm->write_index - pos;
+    } else {
+        avail_size = (ffm->file_size - pos) + (ffm->write_index - FFM_PACKET_SIZE);
+    }
+    }
+    avail_size = (avail_size / ffm->packet_size) * (ffm->packet_size - FFM_HEADER_SIZE) + len;
+    if (size <= avail_size)
+        return 1;
+    else if (ffm->server_attached)
+        return AVERROR(EAGAIN);
+    else
+        return AVERROR_INVALIDDATA;
+}
+
+static int ffm_resync(AVFormatContext *s, uint32_t state)
+{
+    av_log(s, AV_LOG_ERROR, "resyncing\n");
+    while (state != PACKET_ID) {
+        if (avio_feof(s->pb)) {
+            av_log(s, AV_LOG_ERROR, "cannot find FFM syncword\n");
+            return -1;
+        }
+        state = (state << 8) | avio_r8(s->pb);
+    }
+    return 0;
+}
+
+/* first is true if we read the frame header */
+static int ffm_read_data(AVFormatContext *s,
+                         uint8_t *buf, int size, int header)
+{
+    FFMContext *ffm = s->priv_data;
+    AVIOContext *pb = s->pb;
+    int fill_size, size1, frame_offset;
+    uint32_t id;
+    ptrdiff_t len;
+    int64_t last_pos = -1;
+
+    size1 = size;
+    while (size > 0) {
+    redo:
+        len = ffm->packet_end - ffm->packet_ptr;
+        if (len < 0)
+            return -1;
+        if (len > size)
+            len = size;
+        if (len == 0) {
+            if (avio_tell(pb) == ffm->file_size) {
+                if (ffm->server_attached) {
+                    avio_seek(pb, ffm->packet_size, SEEK_SET);
+                } else
+                    return AVERROR_EOF;
+            }
+    retry_read:
+            if (pb->buffer_size != ffm->packet_size) {
+                int64_t tell = avio_tell(pb);
+                int ret = ffio_set_buf_size(pb, ffm->packet_size);
+                if (ret < 0)
+                    return ret;
+                avio_seek(pb, tell, SEEK_SET);
+            }
+            id = avio_rb16(pb); /* PACKET_ID */
+            if (id != PACKET_ID) {
+                if (ffm_resync(s, id) < 0)
+                    return -1;
+                last_pos = avio_tell(pb);
+            }
+            fill_size = avio_rb16(pb);
+            ffm->dts = avio_rb64(pb);
+            frame_offset = avio_rb16(pb);
+            avio_read(pb, ffm->packet, ffm->packet_size - FFM_HEADER_SIZE);
+            if (ffm->packet_size < FFM_HEADER_SIZE + fill_size || frame_offset < 0) {
+                return -1;
+            }
+            ffm->packet_end = ffm->packet + (ffm->packet_size - FFM_HEADER_SIZE - fill_size);
+            /* if first packet or resynchronization packet, we must
+               handle it specifically */
+            if (ffm->first_packet || (frame_offset & 0x8000)) {
+                if (!frame_offset) {
+                    /* This packet has no frame headers in it */
+                    if (avio_tell(pb) >= ffm->packet_size * 3LL) {
+                        int64_t seekback = FFMIN(ffm->packet_size * 2LL, avio_tell(pb) - last_pos);
+                        seekback = FFMAX(seekback, 0);
+                        avio_seek(pb, -seekback, SEEK_CUR);
+                        goto retry_read;
+                    }
+                    /* This is bad, we cannot find a valid frame header */
+                    return 0;
+                }
+                ffm->first_packet = 0;
+                if ((frame_offset & 0x7fff) < FFM_HEADER_SIZE) {
+                    ffm->packet_end = ffm->packet_ptr;
+                    return -1;
+                }
+                ffm->packet_ptr = ffm->packet + (frame_offset & 0x7fff) - FFM_HEADER_SIZE;
+                if (!header)
+                    break;
+            } else {
+                ffm->packet_ptr = ffm->packet;
+            }
+            goto redo;
+        }
+        memcpy(buf, ffm->packet_ptr, len);
+        buf += len;
+        ffm->packet_ptr += len;
+        size -= len;
+        header = 0;
+    }
+    return size1 - size;
+}
+
+/* ensure that actual seeking happens between FFM_PACKET_SIZE
+   and file_size - FFM_PACKET_SIZE */
+static int64_t ffm_seek1(AVFormatContext *s, int64_t pos1)
+{
+    FFMContext *ffm = s->priv_data;
+    AVIOContext *pb = s->pb;
+    int64_t pos;
+
+    pos = FFMIN(pos1, ffm->file_size - FFM_PACKET_SIZE);
+    pos = FFMAX(pos, FFM_PACKET_SIZE);
+    ff_dlog(s, "seek to %"PRIx64" -> %"PRIx64"\n", pos1, pos);
+    return avio_seek(pb, pos, SEEK_SET);
+}
+
+static int64_t get_dts(AVFormatContext *s, int64_t pos)
+{
+    AVIOContext *pb = s->pb;
+    int64_t dts;
+
+    ffm_seek1(s, pos);
+    avio_skip(pb, 4);
+    dts = avio_rb64(pb);
+    ff_dlog(s, "dts=%0.6f\n", dts / 1000000.0);
+    return dts;
+}
+
+static void adjust_write_index(AVFormatContext *s)
+{
+    FFMContext *ffm = s->priv_data;
+    AVIOContext *pb = s->pb;
+    int64_t pts;
+    //int64_t orig_write_index = ffm->write_index;
+    int64_t pos_min, pos_max;
+    int64_t pts_start;
+    int64_t ptr = avio_tell(pb);
+
+
+    pos_min = 0;
+    pos_max = ffm->file_size - 2 * FFM_PACKET_SIZE;
+
+    pts_start = get_dts(s, pos_min);
+
+    pts = get_dts(s, pos_max);
+
+    if (pts - 100000 > pts_start)
+        goto end;
+
+    ffm->write_index = FFM_PACKET_SIZE;
+
+    pts_start = get_dts(s, pos_min);
+
+    pts = get_dts(s, pos_max);
+
+    if (pts - 100000 <= pts_start) {
+        while (1) {
+            int64_t newpos;
+            int64_t newpts;
+
+            newpos = ((pos_max + pos_min) / (2 * FFM_PACKET_SIZE)) * FFM_PACKET_SIZE;
+
+            if (newpos == pos_min)
+                break;
+
+            newpts = get_dts(s, newpos);
+
+            if (newpts - 100000 <= pts) {
+                pos_max = newpos;
+                pts = newpts;
+            } else {
+                pos_min = newpos;
+            }
+        }
+        ffm->write_index += pos_max;
+    }
+
+ end:
+    avio_seek(pb, ptr, SEEK_SET);
+}
+
+
+static int ffm_append_recommended_configuration(AVStream *st, char **conf)
+{
+    int ret;
+    size_t newsize;
+    av_assert0(conf && st);
+    if (!*conf)
+        return 0;
+    if (!st->recommended_encoder_configuration) {
+        st->recommended_encoder_configuration = *conf;
+        *conf = 0;
+        return 0;
+    }
+    newsize = strlen(*conf) + strlen(st->recommended_encoder_configuration) + 2;
+    if ((ret = av_reallocp(&st->recommended_encoder_configuration, newsize)) < 0)
+        return ret;
+    av_strlcat(st->recommended_encoder_configuration, ",", newsize);
+    av_strlcat(st->recommended_encoder_configuration, *conf, newsize);
+    av_freep(conf);
+    return 0;
+}
+
+#define VALIDATE_PARAMETER(parameter, name, check) {                              \
+    if (check) {                                                                  \
+        av_log(s, AV_LOG_ERROR, "Invalid " name " %d\n", codecpar->parameter);   \
+        ret = AVERROR_INVALIDDATA;                                                \
+        goto fail;                                                                \
+    }                                                                             \
+}
+
+static int ffm2_read_header(AVFormatContext *s)
+{
+    FFMContext *ffm = s->priv_data;
+    AVStream *st = NULL;
+    AVIOContext *pb = s->pb;
+    AVCodecContext *dummy_codec = NULL;
+    AVCodecParameters *codecpar = NULL;
+    const AVCodecDescriptor *codec_desc;
+    int ret;
+    int f_main = 0, f_cprv = -1, f_stvi = -1, f_stau = -1;
+    AVCodec *enc;
+    char *buffer;
+
+    ffm->packet_size = avio_rb32(pb);
+    if (ffm->packet_size != FFM_PACKET_SIZE) {
+        av_log(s, AV_LOG_ERROR, "Invalid packet size %d, expected size was %d\n",
+               ffm->packet_size, FFM_PACKET_SIZE);
+        ret = AVERROR_INVALIDDATA;
+        goto fail;
+    }
+
+    ffm->write_index = avio_rb64(pb);
+    /* get also filesize */
+    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {
+        ffm->file_size = avio_size(pb);
+        if (ffm->write_index && 0)
+            adjust_write_index(s);
+    } else {
+        ffm->file_size = (UINT64_C(1) << 63) - 1;
+    }
+    dummy_codec = avcodec_alloc_context3(NULL);
+
+    while(!avio_feof(pb)) {
+        unsigned id = avio_rb32(pb);
+        unsigned size = avio_rb32(pb);
+        int64_t next = avio_tell(pb) + size;
+        char rc_eq_buf[128];
+        int flags;
+
+        if(!id)
+            break;
+
+        switch(id) {
+        case MKBETAG('M', 'A', 'I', 'N'):
+            if (f_main++) {
+                ret = AVERROR(EINVAL);
+                goto fail;
+            }
+            avio_rb32(pb); /* nb_streams */
+            avio_rb32(pb); /* total bitrate */
+            break;
+        case MKBETAG('C', 'O', 'M', 'M'):
+            f_cprv = f_stvi = f_stau = 0;
+            st = avformat_new_stream(s, NULL);
+            if (!st) {
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+
+            avpriv_set_pts_info(st, 64, 1, 1000000);
+
+            codecpar = st->codecpar;
+            /* generic info */
+            codecpar->codec_id = avio_rb32(pb);
+            codec_desc = avcodec_descriptor_get(codecpar->codec_id);
+            if (!codec_desc) {
+                av_log(s, AV_LOG_ERROR, "Invalid codec id: %d\n", codecpar->codec_id);
+                codecpar->codec_id = AV_CODEC_ID_NONE;
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            codecpar->codec_type = avio_r8(pb);
+            if (codecpar->codec_type != codec_desc->type) {
+                av_log(s, AV_LOG_ERROR, "Codec type mismatch: expected %d, found %d\n",
+                       codec_desc->type, codecpar->codec_type);
+                codecpar->codec_id = AV_CODEC_ID_NONE;
+                codecpar->codec_type = AVMEDIA_TYPE_UNKNOWN;
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            codecpar->bit_rate = avio_rb32(pb);
+            if (codecpar->bit_rate < 0) {
+                av_log(s, AV_LOG_ERROR, "Invalid bit rate %"PRId64"\n", codecpar->bit_rate);
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            flags = avio_rb32(pb);
+#if FF_API_LAVF_AVCTX
+FF_DISABLE_DEPRECATION_WARNINGS
+            st->codec->flags = flags;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+            avio_rb32(pb); // flags2
+            avio_rb32(pb); // debug
+            if (flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+                int size = avio_rb32(pb);
+                if (size < 0 || size >= FF_MAX_EXTRADATA_SIZE) {
+                    av_log(s, AV_LOG_ERROR, "Invalid extradata size %d\n", size);
+                    ret = AVERROR_INVALIDDATA;
+                    goto fail;
+                }
+                codecpar->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
+                if (!codecpar->extradata) {
+                    ret = AVERROR(ENOMEM);
+                    goto fail;
+                }
+                codecpar->extradata_size = size;
+                avio_read(pb, codecpar->extradata, size);
+            }
+            break;
+        case MKBETAG('S', 'T', 'V', 'I'):
+            if (f_stvi++ || codecpar->codec_type != AVMEDIA_TYPE_VIDEO) {
+                ret = AVERROR(EINVAL);
+                goto fail;
+            }
+            avio_rb32(pb); // time_base.num
+            avio_rb32(pb); // time_base.den
+            codecpar->width = avio_rb16(pb);
+            codecpar->height = avio_rb16(pb);
+            ret = av_image_check_size(codecpar->width, codecpar->height, 0, s);
+            if (ret < 0)
+                goto fail;
+            avio_rb16(pb); // gop_size
+            codecpar->format = avio_rb32(pb);
+            if (!av_pix_fmt_desc_get(codecpar->format)) {
+                av_log(s, AV_LOG_ERROR, "Invalid pix fmt id: %d\n", codecpar->format);
+                codecpar->format = AV_PIX_FMT_NONE;
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            avio_r8(pb);   // qmin
+            avio_r8(pb);   // qmax
+            avio_r8(pb);   // max_qdiff
+            avio_rb16(pb); // qcompress / 10000.0
+            avio_rb16(pb); // qblur / 10000.0
+            avio_rb32(pb); // bit_rate_tolerance
+            avio_get_str(pb, INT_MAX, rc_eq_buf, sizeof(rc_eq_buf));
+
+            avio_rb32(pb); // rc_max_rate
+            avio_rb32(pb); // rc_min_rate
+            avio_rb32(pb); // rc_buffer_size
+            avio_rb64(pb); // i_quant_factor
+            avio_rb64(pb); // b_quant_factor
+            avio_rb64(pb); // i_quant_offset
+            avio_rb64(pb); // b_quant_offset
+            avio_rb32(pb); // dct_algo
+            avio_rb32(pb); // strict_std_compliance
+            avio_rb32(pb); // max_b_frames
+            avio_rb32(pb); // mpeg_quant
+            avio_rb32(pb); // intra_dc_precision
+            avio_rb32(pb); // me_method
+            avio_rb32(pb); // mb_decision
+            avio_rb32(pb); // nsse_weight
+            avio_rb32(pb); // frame_skip_cmp
+            avio_rb64(pb); // rc_buffer_aggressivity
+            codecpar->codec_tag = avio_rb32(pb);
+            avio_r8(pb);   // thread_count
+            avio_rb32(pb); // coder_type
+            avio_rb32(pb); // me_cmp
+            avio_rb32(pb); // me_subpel_quality
+            avio_rb32(pb); // me_range
+            avio_rb32(pb); // keyint_min
+            avio_rb32(pb); // scenechange_threshold
+            avio_rb32(pb); // b_frame_strategy
+            avio_rb64(pb); // qcompress
+            avio_rb64(pb); // qblur
+            avio_rb32(pb); // max_qdiff
+            avio_rb32(pb); // refs
+            break;
+        case MKBETAG('S', 'T', 'A', 'U'):
+            if (f_stau++ || codecpar->codec_type != AVMEDIA_TYPE_AUDIO) {
+                ret = AVERROR(EINVAL);
+                goto fail;
+            }
+            codecpar->sample_rate = avio_rb32(pb);
+            VALIDATE_PARAMETER(sample_rate, "sample rate",        codecpar->sample_rate < 0)
+            codecpar->channels = avio_rl16(pb);
+            VALIDATE_PARAMETER(channels,    "number of channels", codecpar->channels < 0)
+            codecpar->frame_size = avio_rl16(pb);
+            VALIDATE_PARAMETER(frame_size,  "frame size",         codecpar->frame_size < 0)
+            break;
+        case MKBETAG('C', 'P', 'R', 'V'):
+            if (f_cprv++) {
+                ret = AVERROR(EINVAL);
+                goto fail;
+            }
+            enc = avcodec_find_encoder(codecpar->codec_id);
+            if (enc && enc->priv_data_size && enc->priv_class) {
+                buffer = av_malloc(size + 1);
+                if (!buffer) {
+                    ret = AVERROR(ENOMEM);
+                    goto fail;
+                }
+                avio_get_str(pb, size, buffer, size + 1);
+                if ((ret = ffm_append_recommended_configuration(st, &buffer)) < 0)
+                    goto fail;
+            }
+            break;
+        case MKBETAG('S', '2', 'V', 'I'):
+            if (f_stvi++ || !size || codecpar->codec_type != AVMEDIA_TYPE_VIDEO) {
+                ret = AVERROR(EINVAL);
+                goto fail;
+            }
+            buffer = av_malloc(size);
+            if (!buffer) {
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+            avio_get_str(pb, INT_MAX, buffer, size);
+            // The lack of AVOptions support in AVCodecParameters makes this back and forth copying needed
+            avcodec_parameters_to_context(dummy_codec, codecpar);
+            av_set_options_string(dummy_codec, buffer, "=", ",");
+            avcodec_parameters_from_context(codecpar, dummy_codec);
+            if ((ret = ffm_append_recommended_configuration(st, &buffer)) < 0)
+                goto fail;
+            break;
+        case MKBETAG('S', '2', 'A', 'U'):
+            if (f_stau++ || !size || codecpar->codec_type != AVMEDIA_TYPE_AUDIO) {
+                ret = AVERROR(EINVAL);
+                goto fail;
+            }
+            buffer = av_malloc(size);
+            if (!buffer) {
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+            avio_get_str(pb, INT_MAX, buffer, size);
+            // The lack of AVOptions support in AVCodecParameters makes this back and forth copying needed
+            avcodec_parameters_to_context(dummy_codec, codecpar);
+            av_set_options_string(dummy_codec, buffer, "=", ",");
+            avcodec_parameters_from_context(codecpar, dummy_codec);
+            if ((ret = ffm_append_recommended_configuration(st, &buffer)) < 0)
+                goto fail;
+            break;
+        }
+        avio_seek(pb, next, SEEK_SET);
+    }
+
+    /* get until end of block reached */
+    while ((avio_tell(pb) % ffm->packet_size) != 0 && !pb->eof_reached)
+        avio_r8(pb);
+
+    /* init packet demux */
+    ffm->packet_ptr = ffm->packet;
+    ffm->packet_end = ffm->packet;
+    ffm->frame_offset = 0;
+    ffm->dts = 0;
+    ffm->read_state = READ_HEADER;
+    ffm->first_packet = 1;
+    avcodec_free_context(&dummy_codec);
+    return 0;
+ fail:
+    avcodec_free_context(&dummy_codec);
+    return ret;
+}
+
+static int ffm_read_header(AVFormatContext *s)
+{
+    FFMContext *ffm = s->priv_data;
+    AVStream *st;
+    AVIOContext *pb = s->pb;
+    AVCodecContext *dummy_codec = NULL;
+    AVCodecParameters *codecpar;
+    const AVCodecDescriptor *codec_desc;
+    int i, nb_streams, ret;
+    uint32_t tag;
+
+    /* header */
+    tag = avio_rl32(pb);
+    if (tag == MKTAG('F', 'F', 'M', '2'))
+        return ffm2_read_header(s);
+    if (tag != MKTAG('F', 'F', 'M', '1')) {
+        ret = AVERROR_INVALIDDATA;
+        goto fail;
+    }
+    ffm->packet_size = avio_rb32(pb);
+    if (ffm->packet_size != FFM_PACKET_SIZE) {
+        ret = AVERROR_INVALIDDATA;
+        goto fail;
+    }
+    ffm->write_index = avio_rb64(pb);
+    /* get also filesize */
+    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {
+        ffm->file_size = avio_size(pb);
+        if (ffm->write_index && 0)
+            adjust_write_index(s);
+    } else {
+        ffm->file_size = (UINT64_C(1) << 63) - 1;
+    }
+    dummy_codec = avcodec_alloc_context3(NULL);
+
+    nb_streams = avio_rb32(pb);
+    avio_rb32(pb); /* total bitrate */
+    /* read each stream */
+    for(i=0;i<nb_streams;i++) {
+        char rc_eq_buf[128];
+        int flags;
+
+        st = avformat_new_stream(s, NULL);
+        if (!st) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+
+        avpriv_set_pts_info(st, 64, 1, 1000000);
+
+        codecpar = st->codecpar;
+        /* generic info */
+        codecpar->codec_id = avio_rb32(pb);
+        codec_desc = avcodec_descriptor_get(codecpar->codec_id);
+        if (!codec_desc) {
+            av_log(s, AV_LOG_ERROR, "Invalid codec id: %d\n", codecpar->codec_id);
+            codecpar->codec_id = AV_CODEC_ID_NONE;
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+        codecpar->codec_type = avio_r8(pb); /* codec_type */
+        if (codecpar->codec_type != codec_desc->type) {
+            av_log(s, AV_LOG_ERROR, "Codec type mismatch: expected %d, found %d\n",
+                   codec_desc->type, codecpar->codec_type);
+            codecpar->codec_id = AV_CODEC_ID_NONE;
+            codecpar->codec_type = AVMEDIA_TYPE_UNKNOWN;
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+        codecpar->bit_rate = avio_rb32(pb);
+        if (codecpar->bit_rate < 0) {
+            av_log(s, AV_LOG_WARNING, "Invalid bit rate %"PRId64"\n", codecpar->bit_rate);
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+        flags = avio_rb32(pb);
+#if FF_API_LAVF_AVCTX
+FF_DISABLE_DEPRECATION_WARNINGS
+            st->codec->flags = flags;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+        avio_rb32(pb); // flags2
+        avio_rb32(pb); // debug
+        /* specific info */
+        switch(codecpar->codec_type) {
+        case AVMEDIA_TYPE_VIDEO:
+            avio_rb32(pb); // time_base.num
+            avio_rb32(pb); // time_base.den
+            codecpar->width = avio_rb16(pb);
+            codecpar->height = avio_rb16(pb);
+            if ((ret = av_image_check_size(codecpar->width, codecpar->height, 0, s)) < 0)
+                goto fail;
+            avio_rb16(pb); // gop_size
+            codecpar->format = avio_rb32(pb);
+            if (!av_pix_fmt_desc_get(codecpar->format)) {
+                av_log(s, AV_LOG_ERROR, "Invalid pix fmt id: %d\n", codecpar->format);
+                codecpar->format = AV_PIX_FMT_NONE;
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            avio_r8(pb);   // qmin
+            avio_r8(pb);   // qmax
+            avio_r8(pb);   // max_qdiff
+            avio_rb16(pb); // qcompress / 10000.0
+            avio_rb16(pb); // qblur / 10000.0
+            avio_rb32(pb); // bit_rate_tolerance
+            avio_get_str(pb, INT_MAX, rc_eq_buf, sizeof(rc_eq_buf));
+
+            avio_rb32(pb); // rc_max_rate
+            avio_rb32(pb); // rc_min_rate
+            avio_rb32(pb); // rc_buffer_size
+            avio_rb64(pb); // i_quant_factor
+            avio_rb64(pb); // b_quant_factor
+            avio_rb64(pb); // i_quant_offset
+            avio_rb64(pb); // b_quant_offset
+            avio_rb32(pb); // dct_algo
+            avio_rb32(pb); // strict_std_compliance
+            avio_rb32(pb); // max_b_frames
+            avio_rb32(pb); // mpeg_quant
+            avio_rb32(pb); // intra_dc_precision
+            avio_rb32(pb); // me_method
+            avio_rb32(pb); // mb_decision
+            avio_rb32(pb); // nsse_weight
+            avio_rb32(pb); // frame_skip_cmp
+            avio_rb64(pb); // rc_buffer_aggressivity
+            codecpar->codec_tag = avio_rb32(pb);
+            avio_r8(pb);   // thread_count
+            avio_rb32(pb); // coder_type
+            avio_rb32(pb); // me_cmp
+            avio_rb32(pb); // me_subpel_quality
+            avio_rb32(pb); // me_range
+            avio_rb32(pb); // keyint_min
+            avio_rb32(pb); // scenechange_threshold
+            avio_rb32(pb); // b_frame_strategy
+            avio_rb64(pb); // qcompress
+            avio_rb64(pb); // qblur
+            avio_rb32(pb); // max_qdiff
+            avio_rb32(pb); // refs
+            break;
+        case AVMEDIA_TYPE_AUDIO:
+            codecpar->sample_rate = avio_rb32(pb);
+            VALIDATE_PARAMETER(sample_rate, "sample rate",        codecpar->sample_rate < 0)
+            codecpar->channels = avio_rl16(pb);
+            VALIDATE_PARAMETER(channels,    "number of channels", codecpar->channels < 0)
+            codecpar->frame_size = avio_rl16(pb);
+            VALIDATE_PARAMETER(frame_size,  "frame size",         codecpar->frame_size < 0)
+            break;
+        default:
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+        if (flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+            int size = avio_rb32(pb);
+            if (size < 0 || size >= FF_MAX_EXTRADATA_SIZE) {
+                av_log(s, AV_LOG_ERROR, "Invalid extradata size %d\n", size);
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            codecpar->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
+            if (!codecpar->extradata) {
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+            codecpar->extradata_size = size;
+            avio_read(pb, codecpar->extradata, size);
+        }
+    }
+
+    /* get until end of block reached */
+    while ((avio_tell(pb) % ffm->packet_size) != 0 && !pb->eof_reached)
+        avio_r8(pb);
+
+    /* init packet demux */
+    ffm->packet_ptr = ffm->packet;
+    ffm->packet_end = ffm->packet;
+    ffm->frame_offset = 0;
+    ffm->dts = 0;
+    ffm->read_state = READ_HEADER;
+    ffm->first_packet = 1;
+    avcodec_free_context(&dummy_codec);
+    return 0;
+ fail:
+    avcodec_free_context(&dummy_codec);
+    return ret;
+}
+
+/* return < 0 if eof */
+static int ffm_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    int size;
+    FFMContext *ffm = s->priv_data;
+    int duration, ret;
+
+    switch(ffm->read_state) {
+    case READ_HEADER:
+        if ((ret = ffm_is_avail_data(s, FRAME_HEADER_SIZE+4)) < 0)
+            return ret;
+
+        ff_dlog(s, "pos=%08"PRIx64" spos=%"PRIx64", write_index=%"PRIx64" size=%"PRIx64"\n",
+               avio_tell(s->pb), s->pb->pos, ffm->write_index, ffm->file_size);
+        if (ffm_read_data(s, ffm->header, FRAME_HEADER_SIZE, 1) !=
+            FRAME_HEADER_SIZE)
+            return -1;
+        if (ffm->header[1] & FLAG_DTS)
+            if (ffm_read_data(s, ffm->header+16, 4, 1) != 4)
+                return -1;
+        ffm->read_state = READ_DATA;
+        /* fall through */
+    case READ_DATA:
+        size = AV_RB24(ffm->header + 2);
+        if ((ret = ffm_is_avail_data(s, size)) < 0)
+            return ret;
+
+        duration = AV_RB24(ffm->header + 5);
+
+        if (av_new_packet(pkt, size) < 0) {
+            return AVERROR(ENOMEM);
+        }
+        pkt->stream_index = ffm->header[0];
+        if ((unsigned)pkt->stream_index >= s->nb_streams) {
+            av_log(s, AV_LOG_ERROR, "invalid stream index %d\n", pkt->stream_index);
+            av_packet_unref(pkt);
+            ffm->read_state = READ_HEADER;
+            return -1;
+        }
+        pkt->pos = avio_tell(s->pb);
+        if (ffm->header[1] & FLAG_KEY_FRAME)
+            pkt->flags |= AV_PKT_FLAG_KEY;
+
+        ffm->read_state = READ_HEADER;
+        if (ffm_read_data(s, pkt->data, size, 0) != size) {
+            /* bad case: desynchronized packet. we cancel all the packet loading */
+            av_packet_unref(pkt);
+            return -1;
+        }
+        pkt->pts = AV_RB64(ffm->header+8);
+        if (ffm->header[1] & FLAG_DTS)
+            pkt->dts = pkt->pts - AV_RB32(ffm->header+16);
+        else
+            pkt->dts = pkt->pts;
+        pkt->duration = duration;
+        break;
+    }
+    return 0;
+}
+
+/* seek to a given time in the file. The file read pointer is
+   positioned at or before pts. XXX: the following code is quite
+   approximative */
+static int ffm_seek(AVFormatContext *s, int stream_index, int64_t wanted_pts, int flags)
+{
+    FFMContext *ffm = s->priv_data;
+    int64_t pos_min, pos_max, pos;
+    int64_t pts_min, pts_max, pts;
+    double pos1;
+
+    ff_dlog(s, "wanted_pts=%0.6f\n", wanted_pts / 1000000.0);
+    /* find the position using linear interpolation (better than
+       dichotomy in typical cases) */
+    if (ffm->write_index && ffm->write_index < ffm->file_size) {
+        if (get_dts(s, FFM_PACKET_SIZE) < wanted_pts) {
+            pos_min = FFM_PACKET_SIZE;
+            pos_max = ffm->write_index - FFM_PACKET_SIZE;
+        } else {
+            pos_min = ffm->write_index;
+            pos_max = ffm->file_size - FFM_PACKET_SIZE;
+        }
+    } else {
+        pos_min = FFM_PACKET_SIZE;
+        pos_max = ffm->file_size - FFM_PACKET_SIZE;
+    }
+    while (pos_min <= pos_max) {
+        pts_min = get_dts(s, pos_min);
+        pts_max = get_dts(s, pos_max);
+        if (pts_min > wanted_pts || pts_max <= wanted_pts) {
+            pos = pts_min > wanted_pts ? pos_min : pos_max;
+            goto found;
+        }
+        /* linear interpolation */
+        pos1 = (double)(pos_max - pos_min) * (double)(wanted_pts - pts_min) /
+            (double)(pts_max - pts_min);
+        pos = (((int64_t)pos1) / FFM_PACKET_SIZE) * FFM_PACKET_SIZE;
+        if (pos <= pos_min)
+            pos = pos_min;
+        else if (pos >= pos_max)
+            pos = pos_max;
+        pts = get_dts(s, pos);
+        /* check if we are lucky */
+        if (pts == wanted_pts) {
+            goto found;
+        } else if (pts > wanted_pts) {
+            pos_max = pos - FFM_PACKET_SIZE;
+        } else {
+            pos_min = pos + FFM_PACKET_SIZE;
+        }
+    }
+    pos = (flags & AVSEEK_FLAG_BACKWARD) ? pos_min : pos_max;
+
+ found:
+    if (ffm_seek1(s, pos) < 0)
+        return -1;
+
+    /* reset read state */
+    ffm->read_state = READ_HEADER;
+    ffm->packet_ptr = ffm->packet;
+    ffm->packet_end = ffm->packet;
+    ffm->first_packet = 1;
+
+    return 0;
+}
+
+static int ffm_probe(AVProbeData *p)
+{
+    if (
+        p->buf[0] == 'F' && p->buf[1] == 'F' && p->buf[2] == 'M' &&
+        (p->buf[3] == '1' || p->buf[3] == '2'))
+        return AVPROBE_SCORE_MAX + 1;
+    return 0;
+}
+
+static const AVOption options[] = {
+    {"server_attached", NULL, offsetof(FFMContext, server_attached), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_EXPORT },
+    {"ffm_write_index", NULL, offsetof(FFMContext, write_index), AV_OPT_TYPE_INT64, {.i64 = 0}, 0, INT64_MAX, AV_OPT_FLAG_EXPORT },
+    {"ffm_file_size", NULL, offsetof(FFMContext, file_size), AV_OPT_TYPE_INT64, {.i64 = 0}, 0, INT64_MAX, AV_OPT_FLAG_EXPORT },
+    { NULL },
+};
+
+static const AVClass ffm_class = {
+    .class_name = "ffm demuxer",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+AVInputFormat ff_ffm_demuxer = {
+    .name           = "ffm",
+    .long_name      = NULL_IF_CONFIG_SMALL("FFM (FFserver live feed)"),
+    .priv_data_size = sizeof(FFMContext),
+    .read_probe     = ffm_probe,
+    .read_header    = ffm_read_header,
+    .read_packet    = ffm_read_packet,
+    .read_seek      = ffm_seek,
+    .priv_class     = &ffm_class,
+};
diff -pruN ffmpeg-4.0.2/libavformat/ffmenc.c upd_ffmpeg-4.0.2/libavformat/ffmenc.c
--- ffmpeg-4.0.2/libavformat/ffmenc.c	1970-01-01 08:00:00.000000000 +0800
+++ upd_ffmpeg-4.0.2/libavformat/ffmenc.c	2018-10-05 10:15:05.196565606 +0700
@@ -0,0 +1,362 @@
+/*
+ * FFM (ffserver live feed) muxer
+ * Copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/intreadwrite.h"
+#include "libavutil/intfloat.h"
+#include "libavutil/avassert.h"
+#include "libavutil/parseutils.h"
+#include "libavutil/opt.h"
+#include "avformat.h"
+#include "avio_internal.h"
+#include "internal.h"
+#include "ffm.h"
+
+static void flush_packet(AVFormatContext *s)
+{
+    FFMContext *ffm = s->priv_data;
+    int fill_size, h;
+    AVIOContext *pb = s->pb;
+
+    fill_size = ffm->packet_end - ffm->packet_ptr;
+    memset(ffm->packet_ptr, 0, fill_size);
+
+    av_assert1(avio_tell(pb) % ffm->packet_size == 0);
+
+    /* put header */
+    avio_wb16(pb, PACKET_ID);
+    avio_wb16(pb, fill_size);
+    avio_wb64(pb, ffm->dts);
+    h = ffm->frame_offset;
+    if (ffm->first_packet)
+        h |= 0x8000;
+    avio_wb16(pb, h);
+    avio_write(pb, ffm->packet, ffm->packet_end - ffm->packet);
+    avio_flush(pb);
+
+    /* prepare next packet */
+    ffm->frame_offset = 0; /* no key frame */
+    ffm->packet_ptr = ffm->packet;
+    ffm->first_packet = 0;
+}
+
+/* 'first' is true if first data of a frame */
+static void ffm_write_data(AVFormatContext *s,
+                           const uint8_t *buf, int size,
+                           int64_t dts, int header)
+{
+    FFMContext *ffm = s->priv_data;
+    int len;
+
+    if (header && ffm->frame_offset == 0) {
+        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
+        ffm->dts = dts;
+    }
+
+    /* write as many packets as needed */
+    while (size > 0) {
+        len = ffm->packet_end - ffm->packet_ptr;
+        if (len > size)
+            len = size;
+        memcpy(ffm->packet_ptr, buf, len);
+
+        ffm->packet_ptr += len;
+        buf += len;
+        size -= len;
+        if (ffm->packet_ptr >= ffm->packet_end)
+            flush_packet(s);
+    }
+}
+
+static void write_header_chunk(AVIOContext *pb, AVIOContext *dpb, unsigned id)
+{
+    uint8_t *dyn_buf;
+    int dyn_size= avio_close_dyn_buf(dpb, &dyn_buf);
+    avio_wb32(pb, id);
+    avio_wb32(pb, dyn_size);
+    avio_write(pb, dyn_buf, dyn_size);
+    av_free(dyn_buf);
+}
+
+static int ffm_write_header_codec_ctx(AVIOContext *pb, AVCodecParameters *ctxpar, unsigned tag, int type)
+{
+    AVIOContext *tmp;
+    char *buf = NULL;
+    int ret, need_coma = 0;
+    AVCodecContext *ctx = NULL;
+
+#define SKIP_DEFAULTS   AV_OPT_SERIALIZE_SKIP_DEFAULTS
+#define OPT_FLAGS_EXACT AV_OPT_SERIALIZE_OPT_FLAGS_EXACT
+#define ENC             AV_OPT_FLAG_ENCODING_PARAM
+
+    if (avio_open_dyn_buf(&tmp) < 0)
+        return AVERROR(ENOMEM);
+
+    // AVCodecParameters does not suport AVOptions, we thus must copy it over to a context that does
+    // otherwise it could be used directly and this would be much simpler
+    ctx = avcodec_alloc_context3(NULL);
+    if (!ctx) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    avcodec_parameters_to_context(ctx, ctxpar);
+
+    if ((ret = av_opt_serialize(ctx, ENC | type, SKIP_DEFAULTS, &buf, '=', ',')) < 0)
+        goto fail;
+    if (buf && strlen(buf)) {
+        avio_write(tmp, buf, strlen(buf));
+        av_freep(&buf);
+        need_coma = 1;
+    }
+    if ((ret = av_opt_serialize(ctx, 0, SKIP_DEFAULTS | OPT_FLAGS_EXACT, &buf, '=', ',')) < 0)
+        goto fail;
+    if (buf && strlen(buf)) {
+        if (need_coma)
+            avio_w8(tmp, ',');
+        avio_write(tmp, buf, strlen(buf));
+    }
+    av_freep(&buf);
+    avio_w8(tmp, 0);
+    write_header_chunk(pb, tmp, tag);
+    avcodec_free_context(&ctx);
+    return 0;
+  fail:
+    av_free(buf);
+    ffio_free_dyn_buf(&tmp);
+    avcodec_free_context(&ctx);
+    return ret;
+
+#undef SKIP_DEFAULTS
+#undef OPT_FLAGS_EXACT
+#undef ENC
+}
+
+static int ffm_write_recommended_config(AVIOContext *pb, AVCodecParameters *codecpar, unsigned tag,
+                                        const char *configuration)
+{
+    int ret;
+    const AVCodec *enc = avcodec_find_encoder(codecpar->codec_id);
+    AVIOContext *tmp;
+    AVDictionaryEntry *t = NULL;
+    AVDictionary *all = NULL, *comm = NULL, *prv = NULL;
+    char *buf = NULL;
+
+    if (!enc || !enc->priv_class || !enc->priv_data_size) {
+        /* codec is not known/has no private options, so save everything as common options */
+        if (avio_open_dyn_buf(&tmp) < 0)
+            return AVERROR(ENOMEM);
+        avio_put_str(tmp, configuration);
+        write_header_chunk(pb, tmp, tag);
+        return 0;
+    }
+
+    if ((ret = av_dict_parse_string(&all, configuration, "=", ",", 0)) < 0)
+        return ret;
+
+    while ((t = av_dict_get(all, "", t, AV_DICT_IGNORE_SUFFIX))) {
+        if (av_opt_find((void *)&enc->priv_class, t->key, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ)) {
+            if ((ret = av_dict_set(&prv, t->key, t->value, 0)) < 0)
+                goto fail;
+        } else if ((ret = av_dict_set(&comm, t->key, t->value, 0)) < 0)
+            goto fail;
+    }
+
+    if (comm) {
+        if ((ret = av_dict_get_string(comm, &buf, '=', ',')) < 0 ||
+            (ret = avio_open_dyn_buf(&tmp)) < 0)
+            goto fail;
+        avio_put_str(tmp, buf);
+        av_freep(&buf);
+        write_header_chunk(pb, tmp, tag);
+    }
+    if (prv) {
+        if ((ret = av_dict_get_string(prv, &buf, '=', ',')) < 0 ||
+            (ret = avio_open_dyn_buf(&tmp)) < 0)
+            goto fail;
+        avio_put_str(tmp, buf);
+        write_header_chunk(pb, tmp, MKBETAG('C', 'P', 'R', 'V'));
+    }
+
+  fail:
+    av_free(buf);
+    av_dict_free(&all);
+    av_dict_free(&comm);
+    av_dict_free(&prv);
+    return ret;
+}
+
+static int ffm_write_header(AVFormatContext *s)
+{
+    FFMContext *ffm = s->priv_data;
+    AVStream *st;
+    AVIOContext *pb = s->pb;
+    AVCodecParameters *codecpar;
+    int bit_rate, i, ret;
+
+    if ((ret = ff_parse_creation_time_metadata(s, &ffm->start_time, 0)) < 0)
+        return ret;
+
+    ffm->packet_size = FFM_PACKET_SIZE;
+
+    /* header */
+    avio_wl32(pb, MKTAG('F', 'F', 'M', '2'));
+    avio_wb32(pb, ffm->packet_size);
+    avio_wb64(pb, 0); /* current write position */
+
+    if(avio_open_dyn_buf(&pb) < 0)
+        return AVERROR(ENOMEM);
+
+    avio_wb32(pb, s->nb_streams);
+    bit_rate = 0;
+    for(i=0;i<s->nb_streams;i++) {
+        st = s->streams[i];
+        bit_rate += st->codecpar->bit_rate;
+    }
+    avio_wb32(pb, bit_rate);
+
+    write_header_chunk(s->pb, pb, MKBETAG('M', 'A', 'I', 'N'));
+
+    /* list of streams */
+    for(i=0;i<s->nb_streams;i++) {
+        int flags = 0;
+        st = s->streams[i];
+        avpriv_set_pts_info(st, 64, 1, 1000000);
+        if(avio_open_dyn_buf(&pb) < 0)
+            return AVERROR(ENOMEM);
+
+        codecpar = st->codecpar;
+        /* generic info */
+        avio_wb32(pb, codecpar->codec_id);
+        avio_w8(pb, codecpar->codec_type);
+        avio_wb32(pb, codecpar->bit_rate);
+        if (codecpar->extradata_size)
+            flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
+
+        // If the user is not providing us with a configuration we have to fill it in as we cannot access the encoder
+        if (!st->recommended_encoder_configuration) {
+            if (s->flags & AVFMT_FLAG_BITEXACT)
+                flags |= AV_CODEC_FLAG_BITEXACT;
+        }
+
+        avio_wb32(pb, flags);
+        avio_wb32(pb, 0); // flags2
+        avio_wb32(pb, 0); // debug
+        if (codecpar->extradata_size) {
+            avio_wb32(pb, codecpar->extradata_size);
+            avio_write(pb, codecpar->extradata, codecpar->extradata_size);
+        }
+        write_header_chunk(s->pb, pb, MKBETAG('C', 'O', 'M', 'M'));
+        /* specific info */
+        switch(codecpar->codec_type) {
+        case AVMEDIA_TYPE_VIDEO:
+            if (st->recommended_encoder_configuration) {
+                av_log(NULL, AV_LOG_DEBUG, "writing recommended configuration: %s\n",
+                       st->recommended_encoder_configuration);
+                if ((ret = ffm_write_recommended_config(s->pb, codecpar, MKBETAG('S', '2', 'V', 'I'),
+                                                        st->recommended_encoder_configuration)) < 0)
+                return ret;
+            } else if ((ret = ffm_write_header_codec_ctx(s->pb, codecpar, MKBETAG('S', '2', 'V', 'I'), AV_OPT_FLAG_VIDEO_PARAM)) < 0)
+                return ret;
+            break;
+        case AVMEDIA_TYPE_AUDIO:
+            if (st->recommended_encoder_configuration) {
+                av_log(NULL, AV_LOG_DEBUG, "writing recommended configuration: %s\n",
+                       st->recommended_encoder_configuration);
+                if ((ret = ffm_write_recommended_config(s->pb, codecpar, MKBETAG('S', '2', 'A', 'U'),
+                                                        st->recommended_encoder_configuration)) < 0)
+                return ret;
+            } else if ((ret = ffm_write_header_codec_ctx(s->pb, codecpar, MKBETAG('S', '2', 'A', 'U'), AV_OPT_FLAG_AUDIO_PARAM)) < 0)
+                return ret;
+            break;
+        default:
+            return -1;
+        }
+    }
+    pb = s->pb;
+
+    avio_wb64(pb, 0); // end of header
+
+    /* flush until end of block reached */
+    while ((avio_tell(pb) % ffm->packet_size) != 0)
+        avio_w8(pb, 0);
+
+    avio_flush(pb);
+
+    /* init packet mux */
+    ffm->packet_ptr = ffm->packet;
+    ffm->packet_end = ffm->packet + ffm->packet_size - FFM_HEADER_SIZE;
+    av_assert0(ffm->packet_end >= ffm->packet);
+    ffm->frame_offset = 0;
+    ffm->dts = 0;
+    ffm->first_packet = 1;
+
+    return 0;
+}
+
+static int ffm_write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    FFMContext *ffm = s->priv_data;
+    int64_t dts;
+    uint8_t header[FRAME_HEADER_SIZE+4];
+    int header_size = FRAME_HEADER_SIZE;
+
+    dts = ffm->start_time + pkt->dts;
+    /* packet size & key_frame */
+    header[0] = pkt->stream_index;
+    header[1] = 0;
+    if (pkt->flags & AV_PKT_FLAG_KEY)
+        header[1] |= FLAG_KEY_FRAME;
+    AV_WB24(header+2, pkt->size);
+    AV_WB24(header+5, pkt->duration);
+    AV_WB64(header+8, ffm->start_time + pkt->pts);
+    if (pkt->pts != pkt->dts) {
+        header[1] |= FLAG_DTS;
+        AV_WB32(header+16, pkt->pts - pkt->dts);
+        header_size += 4;
+    }
+    ffm_write_data(s, header, header_size, dts, 1);
+    ffm_write_data(s, pkt->data, pkt->size, dts, 0);
+
+    return 0;
+}
+
+static int ffm_write_trailer(AVFormatContext *s)
+{
+    FFMContext *ffm = s->priv_data;
+
+    /* flush packets */
+    if (ffm->packet_ptr > ffm->packet)
+        flush_packet(s);
+
+    return 0;
+}
+
+AVOutputFormat ff_ffm_muxer = {
+    .name              = "ffm",
+    .long_name         = NULL_IF_CONFIG_SMALL("FFM (FFserver live feed)"),
+    .extensions        = "ffm",
+    .priv_data_size    = sizeof(FFMContext),
+    .audio_codec       = AV_CODEC_ID_MP2,
+    .video_codec       = AV_CODEC_ID_MPEG1VIDEO,
+    .write_header      = ffm_write_header,
+    .write_packet      = ffm_write_packet,
+    .write_trailer     = ffm_write_trailer,
+    .flags             = AVFMT_TS_NEGATIVE,
+};
diff -pruN ffmpeg-4.0.2/libavformat/ffm.h upd_ffmpeg-4.0.2/libavformat/ffm.h
--- ffmpeg-4.0.2/libavformat/ffm.h	1970-01-01 08:00:00.000000000 +0800
+++ upd_ffmpeg-4.0.2/libavformat/ffm.h	2018-10-05 10:14:56.476572116 +0700
@@ -0,0 +1,62 @@
+/*
+ * FFM (ffserver live feed) common header
+ * Copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_FFM_H
+#define AVFORMAT_FFM_H
+
+#include <stdint.h>
+#include "avformat.h"
+#include "avio.h"
+
+/* The FFM file is made of blocks of fixed size */
+#define FFM_HEADER_SIZE 14
+#define FFM_PACKET_SIZE 4096
+#define PACKET_ID       0x666d
+
+/* each packet contains frames (which can span several packets */
+#define FRAME_HEADER_SIZE    16
+#define FLAG_KEY_FRAME       0x01
+#define FLAG_DTS             0x02
+
+enum {
+    READ_HEADER,
+    READ_DATA,
+};
+
+typedef struct FFMContext {
+    const AVClass *class;
+    /* only reading mode */
+    int64_t write_index, file_size;
+    int read_state;
+    uint8_t header[FRAME_HEADER_SIZE+4];
+
+    /* read and write */
+    int first_packet; /* true if first packet, needed to set the discontinuity tag */
+    int packet_size;
+    int frame_offset;
+    int64_t dts;
+    uint8_t *packet_ptr, *packet_end;
+    uint8_t packet[FFM_PACKET_SIZE];
+    int64_t start_time;
+    int server_attached;
+} FFMContext;
+
+#endif /* AVFORMAT_FFM_H */
diff -pruN ffmpeg-4.0.2/libavformat/Makefile upd_ffmpeg-4.0.2/libavformat/Makefile
--- ffmpeg-4.0.2/libavformat/Makefile	2018-07-18 20:52:01.000000000 +0700
+++ upd_ffmpeg-4.0.2/libavformat/Makefile	2018-10-05 10:21:59.536256231 +0700
@@ -167,6 +167,8 @@ OBJS-$(CONFIG_EA_DEMUXER)
 OBJS-$(CONFIG_EAC3_DEMUXER)              += ac3dec.o rawdec.o
 OBJS-$(CONFIG_EAC3_MUXER)                += rawenc.o
 OBJS-$(CONFIG_EPAF_DEMUXER)              += epafdec.o pcm.o
+OBJS-$(CONFIG_FFM_DEMUXER)        	  += ffmdec.o
+OBJS-$(CONFIG_FFM_MUXER)          	  += ffmenc.o
 OBJS-$(CONFIG_FFMETADATA_DEMUXER)        += ffmetadec.o
 OBJS-$(CONFIG_FFMETADATA_MUXER)          += ffmetaenc.o
 OBJS-$(CONFIG_FIFO_MUXER)                += fifo.o
